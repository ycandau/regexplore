//------------------------------------------------------------------------------
// Parser class
//------------------------------------------------------------------------------

import { descriptions, warnings } from './re_static_info.js';
import {
  getToken,
  getConcat,
  getBracketClass,
  getParenClose,
} from './re_tokens.js';

import compile from './re_compile.js';
import graph from './re_graph.js';

//------------------------------------------------------------------------------

const typeToDisplayType = {
  charLiteral: 'value',
  escapedChar: 'value',
  charClass: 'value-special',
  bracketChar: 'value',
  bracketRangeLow: 'value-special',
  bracketRangeHigh: 'value-special',
  '.': 'value-special',
  '?': 'quantifier',
  '*': 'quantifier',
  '+': 'quantifier',
  '|': 'operator',
  '(': 'delimiter',
  ')': 'delimiter',
  '[': 'delimiter',
  ']': 'delimiter',
  '-': 'value-special',
  '^': 'operator',
};

//------------------------------------------------------------------------------

const last = (array) => array[array.length - 1];

const isValue = (token) =>
  token.type && token.type !== '|' && token.type !== '(';

const isQuantifier = (token) => ['?', '*', '+'].includes(token.type);

// const isNot = (str) => (s) => s !== str;
const isNotIn = (...args) => (s) => !args.includes(s);

const merge = (obj1, obj2, filter = () => true) => {
  Object.keys(obj2)
    .filter(filter)
    .forEach((key) => (obj1[key] = obj2[key]));
};

const concatLabels = (descriptions, begin, end) => {
  let str = '';
  for (let index = begin; index <= end; index++) {
    str += descriptions[index].label;
  }
  return str;
};

/* eslint no-unused-vars: 0 */

const stringifyTokens = (tokens) => {
  let str = '0';

  tokens.reduce((str, token) => {
    switch (token.type) {
      case 'charLiteral':
      case 'escapedChar':
      case 'charClass':
      case 'bracketClass':
        return str + 'a';
      case '.':
      case '|':
      case '?':
      case '*':
      case '+':
      case '(':
      case ')':
        return str + token.type;
      default:
        throw new Error('Invalid token type');
    }
  }, '0');

  return str + '9';
};

const filterTokens = (tokens) => tokens.filter((token) => !token.invalid);

//------------------------------------------------------------------------------

class Parser {
  constructor(input) {
    this.input = input; // unprocessed input string

    // Temporary state properties used during parsing
    this.pos = 0;
    this.operators = [];

    // Data structures generated by the parser
    this.rpn = [];
    this.descriptions = [];
    this.warnings = [];

    // Data structures generated by the compiler
    this.nfa = null;

    this.parse();
    this.compile();
  }

  //----------------------------------------------------------------------------
  // Helpers

  ch(shift = 0) {
    return this.input[this.pos + shift];
  }

  slice(length) {
    return this.input.slice(this.pos, this.pos + length);
  }

  code(shift = 0) {
    return this.input.charCodeAt(this.pos + shift);
  }

  remaining() {
    return this.input.length - this.pos;
  }

  currentIndex() {
    return this.descriptions.length - 1;
  }

  //----------------------------------------------------------------------------

  // Read the next token and advance the position in the input string
  readToken() {
    // Bracket expressions
    if (this.ch() === '[') {
      return this.readBracketExpression();
    }

    const token = getToken(this.slice(2), this.pos, this.currentIndex() + 1);
    this.addDescription(token.label, token.type);
    this.pos += token.label.length;
    return token;
  }

  topOperatorIs(label) {
    const operator = this.operators[this.operators.length - 1];
    return operator !== undefined && operator.label === label;
  }

  // Transfer the stacked operator to the RPN queue if it is at the top
  transferOperator(ch) {
    if (this.topOperatorIs(ch)) {
      const operator = this.operators.pop();
      this.rpn.push(operator);
    }
  }

  // Add an implicit concat when necessary
  concat() {
    this.transferOperator('~');
    this.operators.push(getConcat());
  }

  //----------------------------------------------------------------------------

  //----------------------------------------------------------------------------

  tokenize() {
    this.tokens = [];
    while (this.remaining()) {
      const token = this.readToken();
      this.tokens.push(token);
    }
  }

  //----------------------------------------------------------------------------

  //----------------------------------------------------------------------------

  ppParentheses() {
    if (this.tokens.length === 0) return;

    let parens = [];

    for (const token of this.tokens) {
      if (token.type === '(') {
        parens.push(token);
      }
      if (token.type === ')') {
        // Syntax error: missing opening parenthesis
        if (parens.length === 0) {
          this.addWarning('!)', token.pos, token.index);
          this.describe({ warning: '!)' }, token.index);
          token.invalid = true;
        }
        parens.pop();
      }
    }
    // Syntax error: missing closing parenthesis
    const { pos, index } = last(this.tokens);
    while (parens.length > 0) {
      const close = getParenClose();
      const open = parens.pop();
      close.pos = pos;
      close.index = index;
      this.tokens.push(close);
      this.addWarning('!(', open.pos, open.index);
    }

    this.tokens = filterTokens(this.tokens);
  }

  //----------------------------------------------------------------------------

  ppQuantifiers() {
    let prevToken = {};
    for (const token of this.tokens) {
      switch (token.type) {
        case '?':
        case '*':
        case '+':
          // Syntax error: redundant quantifiers
          if (isQuantifier(prevToken)) {
            const label = `${prevToken.type}${token.type}`;
            const sub = label === '??' ? '?' : label === '++' ? '+' : '*';
            prevToken.label = sub;
            prevToken.type = sub;
            const msg = `The parser is substituting '${label}' with '${sub}'`;
            this.addWarning('!**', token.pos, token.index, { label, msg });
            this.describe({ warning: '!**' }, token.index);
            token.invalid = true;
          }

          // Syntax error: no value before quantifier
          else if (!isValue(prevToken)) {
            const label = token.type;
            this.addWarning('!E*', token.pos, token.index, { label });
            this.describe({ warning: '!E*' }, token.index);
            token.invalid = true;
          } else {
            prevToken = token;
          }
          break;
        default:
          prevToken = token;
          break;
      }
    }
    this.tokens = filterTokens(this.tokens);
  }

  //----------------------------------------------------------------------------

  ppAlternationsForward() {
    let prevToken = {};
    for (const token of this.tokens) {
      switch (token.type) {
        case '|':
          // Syntax error: no value before alternation
          if (!isValue(prevToken)) {
            const label = token.type;
            this.addWarning('!E|', token.pos, token.index, { label });
            this.describe({ warning: '!E|' }, token.index);
            token.invalid = true;
          } else {
            prevToken = token;
          }
          break;
        default:
          prevToken = token;
          break;
      }
    }
    this.tokens = filterTokens(this.tokens);
  }

  //----------------------------------------------------------------------------

  ppAlternationsBackward() {
    let prevToken = { type: ')' };
    for (let i = this.tokens.length - 1; i >= 0; i--) {
      const token = this.tokens[i];
      switch (token.type) {
        case '|':
          // Syntax error: no value after alternation
          if (prevToken.type === ')') {
            const label = token.type;
            this.addWarning('!|E', token.pos, token.index, { label });
            this.describe({ warning: '!|E' }, token.index);
            token.invalid = true;
          }
          break;
        default:
          break;
      }
      prevToken = token;
    }
    this.tokens = filterTokens(this.tokens);
  }

  //----------------------------------------------------------------------------

  ppEmptyParentheses() {
    let nOpen = 0;
    let nClose = 0;

    // Add temporary terminal token
    this.tokens.push({ type: 'end', invalid: true });

    for (let i = 0; i < this.tokens.length; i++) {
      const token = this.tokens[i];
      switch (token.type) {
        case '(':
          nOpen++;
          break;
        case ')':
          nClose++;
          break;
        default:
          if (nOpen && nClose) {
            // Syntax error: no value inside parentheses
            const count = Math.min(nOpen, nClose);
            const begin = i - count - nClose;
            const end = i + count - nClose;
            for (let ind = begin; ind < end; ind++) {
              const paren = this.tokens[ind];
              paren.invalid = true;
              this.describe({ warning: '!()' }, paren.index);
            }
            const first = this.tokens[begin];
            this.addWarning('!()', first.pos, first.index);
          }
          nOpen = 0;
          nClose = 0;
          break;
      }
    }
    this.tokens = filterTokens(this.tokens);
  }

  //----------------------------------------------------------------------------

  preProcess() {
    this.ppParentheses();
    this.ppQuantifiers();
    this.ppAlternationsForward();
    this.ppAlternationsBackward();
    this.ppEmptyParentheses();
  }

  //----------------------------------------------------------------------------
  // Generate a queue of tokens in reverse polish notation (RPN)
  // using a simplified shunting-yard algorithm
  toRpn() {
    this.rpn = [];
    this.operators = [];
    let prevToken = {};

    for (const token of this.tokens) {
      switch (token.type) {
        case 'charLiteral':
        case 'escapedChar':
        case 'charClass':
        case 'bracketClass':
        case '.':
          if (isValue(prevToken)) this.concat();
          this.rpn.push(token);
          break;

        case '|':
          this.transferOperator('~');
          this.transferOperator('|');
          this.operators.push(token);
          break;

        case '?':
        case '*':
        case '+':
          this.rpn.push(token);
          break;

        case '(':
          if (isValue(prevToken)) this.concat();
          token.begin = token.index;
          this.operators.push(token);
          break;

        case ')':
          this.transferOperator('~');
          this.transferOperator('|');
          const open = this.operators.pop();
          const begin = open.begin;
          const end = token.index;
          open.end = end;

          this.rpn.push(open);
          this.describe({ begin, end }, begin);
          this.describe({ begin, end }, end);
          break;

        default:
          throw new Error('Invalid token type');
      }
      prevToken = token;
    }
    this.transferOperator('~');
    this.transferOperator('|');
  }

  parse() {
    this.tokenize();
    this.preProcess();
    this.toRpn();
  }

  //----------------------------------------------------------------------------
  // Descriptions

  addDescription(label, type) {
    const index = this.currentIndex() + 1;
    const pos = this.pos;
    this.descriptions.push({ index, pos, label, type });
  }

  describe(info, index) {
    const ind = index !== undefined ? index : this.currentIndex();
    const description = this.descriptions[ind];
    for (const key in info) description[key] = info[key];
  }

  //----------------------------------------------------------------------------
  // Bracket expressions

  eatToken(type) {
    this.addDescription(this.ch(), type);
    this.pos++;
  }

  tryEatToken(type) {
    if (this.ch() === type) {
      this.addDescription(type, type);
      this.pos++;
      return true;
    }
    return false;
  }

  readBracketChar(matches) {
    this.addDescription(this.ch(), 'bracketChar');
    matches.add(this.ch());
    this.pos++;
  }

  tryReadBracketChar(label, matches) {
    if (this.ch() === label) {
      this.addDescription(label, 'bracketChar');
      matches.add(label);
      this.pos++;
      return true;
    }
    return false;
  }

  tryReadBracketRange(matches) {
    if (this.remaining() < 3 || this.ch(1) !== '-' || this.ch(2) === ']') {
      return false;
    }

    const rangeLow = this.code(0);
    const rangeHigh = this.code(2);
    for (let i = rangeLow; i <= rangeHigh; i++) {
      matches.add(String.fromCharCode(i));
    }

    this.eatToken('bracketRangeLow');
    this.eatToken('-');
    this.eatToken('bracketRangeHigh');

    return true;
  }

  readBracketExpression() {
    const pos = this.pos;

    this.eatToken('[');
    const set = new Set();
    const begin = this.currentIndex();
    const negate = this.tryEatToken('^');

    // Special characters are treated as literals at the beginning
    this.tryReadBracketChar(']', set) || this.tryReadBracketChar('-', set);

    // Try char range, otherwise read char literal
    while (this.remaining() && this.ch() !== ']') {
      this.tryReadBracketRange(set) || this.readBracketChar(set);
    }

    // Finalize
    const end = this.currentIndex() + 1;
    const matches = [...set].join('');
    const info = { begin, end, negate, matches };
    this.describe(info, begin);

    // Syntax error: open bracket with no closing
    const hasClosingBracket = this.ch() === ']';
    if (hasClosingBracket) {
      this.eatToken(']');
      this.describe(info, end);
    } else {
      this.addWarning('![', pos, begin);
    }

    const closingBracket = hasClosingBracket ? '' : ']';
    const label = this.input.slice(pos, this.pos) + closingBracket;
    return getBracketClass(label, { ...info, pos, index: begin });
  }

  //----------------------------------------------------------------------------
  // Compile NFA

  compile() {
    const { nfa, nodes } = compile(this.rpn);
    this.nfa = nfa;
    this.nodes = nodes;

    // Merge compile information from tokens back into descriptions
    const filter = isNotIn('label', 'type', 'match');

    this.rpn.forEach((token) => {
      if (token.type === '~') return;
      merge(this.descriptions[token.index], token, filter);
    });

    // Generate editorInfo object
    this.editorInfo = this.descriptions.map((descrip) => ({
      ...descrip,
      displayType: typeToDisplayType[descrip.type],
    }));

    this.graph = graph(nodes);
  }

  //----------------------------------------------------------------------------

  tokenInfo(index) {
    const token = this.descriptions[index];
    const type = token.type === 'charClass' ? token.label : token.type;

    const operands = [];
    if (token.begin !== undefined && token.end !== undefined) {
      operands.push(
        concatLabels(this.descriptions, token.begin + 1, token.end - 1)
      );
    }
    if (token.beginL !== undefined && token.endL !== undefined) {
      operands.push(concatLabels(this.descriptions, token.beginL, token.endL));
    }
    if (token.beginR !== undefined && token.endR !== undefined) {
      operands.push(concatLabels(this.descriptions, token.beginR, token.endR));
    }

    const info = { pos: token.pos, label: token.label, ...descriptions[type] };
    if (operands.length) info.operands = operands;
    return info;
  }

  //----------------------------------------------------------------------------
  // Apply fixes

  addWarning(type, pos, index, config) {
    const warning = { pos, index, ...warnings[type], ...config };
    this.warnings.push(warning);
  }

  //----------------------------------------------------------------------------

  fix() {
    let stack = [];
    this.rpn.forEach((token) => {
      let str1 = '';
      let str2 = '';
      switch (token.type) {
        case 'charLiteral':
        case 'escapedChar':
        case 'charClass':
        case 'bracketClass':
        case '.':
          stack.push(token.label);
          break;
        case '?':
        case '*':
        case '+':
          str1 = stack.pop();
          stack.push(str1 + token.label);
          break;
        case '|':
          str1 = stack.pop();
          str2 = stack.pop();
          stack.push(str2 + '|' + str1);
          break;
        case '(':
          str1 = stack.pop();
          stack.push('(' + str1 + ')');
          break;
        case '~':
          str1 = stack.pop();
          str2 = stack.pop();
          stack.push(str2 + str1);
          break;
        default:
          break;
      }
    });
    return stack[0] || '';
  }
}

//------------------------------------------------------------------------------

export default Parser;

// const parser = new Parser('ab((**((**((');
