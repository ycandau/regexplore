//------------------------------------------------------------------------------
// Parser class
//------------------------------------------------------------------------------

import Tokens from './re_tokens.js';
import Descriptions from './re_descriptions.js';
import { last, logHeading } from './re_helpers.js';

//------------------------------------------------------------------------------

class Parser {
  constructor(input) {
    this.input = input; // unprocessed input string

    // Temporary state properties used during parsing
    this.pos = 0;
    this.prevToken = {};
    this.operators = [];

    // Data structures generated by the parser
    this.rpn = [];
    this.descriptions = [];

    // this.firstState = null;
    // this.descriptions = [];
    // this.fragments = [];
  }

  //----------------------------------------------------------------------------
  // Helpers

  ch(shift = 0) {
    return this.input[this.pos + shift];
  }

  slice(length) {
    return this.input.slice(this.pos, this.pos + length);
  }

  code(shift = 0) {
    return this.input.charCodeAt(this.pos + shift);
  }

  remaining() {
    return this.input.length - this.pos;
  }

  logStr() {
    logHeading('Input', this.input);
  }

  log() {
    this.logStr();
    this.logRPN();
    // console.log(`RPN:       ${this.rpn}`);
    // console.log(`Fragments [${this.fragments.length}]: ${this.fragments}`);
    // console.log(`Operators [${this.operators.length}]: ${this.operators}`);
    // console.log('Graph');
    // this.firstState.logAll();
  }

  //----------------------------------------------------------------------------
  // Convert to Reverse Polish Notation (RPN)

  // Read the next token and advance the position in the input string
  readToken() {
    const ch = this.ch();
    // Escaped characters
    if (ch === '\\') {
      const label = this.slice(2);
      this.pos += 2;
      return Tokens.types[label] || Tokens.escapedLiteral(label);
    }
    // Bracket expressions
    if (ch === '[') {
      const token = this.readBracketExpression();
      this.pos += 1; // @todo
      return token;
    }
    // Standard tokens
    this.pos++;
    return Tokens.types[ch] || Tokens.charLiteral(ch);
  }

  // Transfer the operator to the RPN stack if it is at the top
  transferOperator(ch) {
    const operator = last(this.operators);
    if (operator && operator.label === ch) {
      this.operators.pop();
      this.rpn.push(operator);
    }
  }

  // Add an implicit concat when necessary
  concat() {
    this.transferOperator('~');
    this.operators.push(Tokens.concat);
  }

  // Generate a stack of tokens in reverse polish notation
  // using a simplified shunting-yard algorithm
  generateRPN() {
    while (this.remaining()) {
      const token = this.readToken();
      switch (token.type) {
        case 'charclass':
          if (this.prevToken.concatAfter) this.concat();
          this.rpn.push(token);
          break;
        case 'alternate':
          this.transferOperator('~');
          this.transferOperator('|');
          this.operators.push(token);
          break;
        case 'repeat':
          this.rpn.push(token);
          break;
        case 'parenOpen':
          if (this.prevToken.concatAfter) this.concat();
          this.operators.push(token);
          break;
        case 'parenClose':
          this.transferOperator('~');
          this.transferOperator('|');
          this.operators.pop();
          break;
        default:
          break;
      }
      this.prevToken = token;
    }
    this.transferOperator('~');
    this.transferOperator('|');
  }

  // Log the stack of tokens
  logRPN() {
    logHeading('RPN');
    this.rpn.forEach((token) => {
      console.log(`  ${token.label} : ${token.name}`);
    });
  }

  //----------------------------------------------------------------------------
  // Descriptions

  pushDescription(label, type, config = {}) {
    this.descriptions.push({
      label,
      ...Descriptions[type],
      ...config,
    });
  }

  describe(pos, info) {
    const description = this.descriptions[pos];
    for (const key in info) description[key] = info[key];
  }

  //----------------------------------------------------------------------------
  // Bracket expressions

  eatToken(type) {
    this.pushDescription(this.ch(), type);
    this.pos++;
  }

  tryEatToken(label, type) {
    if (this.ch() === label) {
      this.pushDescription(label, type);
      this.pos++;
      return true;
    }
    return false;
  }

  readBracketChar(matches) {
    this.pushDescription(this.ch(), 'bracketChar');
    this.pos++;
    matches.add(this.ch());
  }

  tryReadBracketChar(label, matches) {
    if (this.ch() === label) {
      this.pushDescription(label, 'bracketChar');
      this.pos++;
      matches.add(label);
      return true;
    }
    return false;
  }

  tryReadBracketRange(matches) {
    if (this.remaining() < 3 || this.ch(1) !== '-' || this.ch(2) === ']') {
      return false;
    }

    const rangeLow = this.code(0);
    const rangeHigh = this.code(2);
    for (let i = rangeLow; i <= rangeHigh; i++) {
      matches.add(String.fromCharCode(i));
    }

    this.eatToken('bracketRangeLow');
    this.eatToken('-');
    this.eatToken('bracketRangeHigh');

    return true;
  }

  readBracketExpression() {
    const begin = this.pos;
    const matches = new Set();

    this.eatToken('[');
    const negate = this.tryEatToken('^');

    this.tryReadBracketChar(']', matches) ||
      this.tryReadBracketChar('-', matches);

    while (this.remaining()) {
      if (this.ch() === ']') {
        this.endBracketExpression({ begin, negate, matches });
        return;
      }
      this.tryReadBracketRange(matches) || this.readBracketChar(matches);
    }
    this.raise('Bracket expression not closed.');
  }

  endBracketExpression({ begin, negate, matches }) {
    const end = this.pos;
    const list = [...matches];
    const info = { begin, end, negate, list };
    this.eatToken(']');
    this.describe(begin, info);
    this.describe(end, info);
  }
}

export { Parser };

// const parser = new Parser('a.\\d\\.(b?c|d*)e|f');
// parser.generateRPN();
// parser.log();
